[{"title":"数据结构","date":"2021-11-21T08:19:16.000Z","path":"2021/11/21/数据结构/","text":"数据结构分类 数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成 。 常用的数据结构有：数组，栈，链表，队列，树，图，堆，散列表等，如图所示： 每一种数据结构都有着独特的数据存储方式，下面为大家介绍它们的结构和优缺点。 1、数组 数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。例如下面这段代码就是将数组的第一个元素赋值为 1。 1var data = new Array[100]；data[0] = 1; 优点： 1、按照索引查询元素速度快 2、按照索引遍历数组方便 缺点： 1、数组的大小固定后就无法扩容了 2、数组只能存储一种类型的数据 3、添加，删除的操作慢，因为要移动其他的元素。 适用场景： 频繁查询，对存储空间要求不大，很少增加和删除的情况。 2、栈 栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。 栈的结构就像一个集装箱，越先放进去的东西越晚才能拿出来，所以，栈常应用于实现递归功能方面的场景，例如斐波那契数列。 3、队列 队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队，示例图如下： 使用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。 4、链表 **链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。**根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。 链表的优点： 链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素； 添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快； 缺点： 因为含有大量的指针域，占用空间较大； 查找元素需要遍历链表来查找，非常耗时。 适用场景： 数据量较小，需要频繁增加，删除操作的场景 5、树 树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点： 每个节点有零个或多个子节点； 没有父节点的节点称为根节点； 每一个非根节点有且只有一个父节点； 除了根节点外，每个子节点可以分为多个不相交的子树； 在日常的应用中，我们讨论和用的更多的是树的其中一种结构，就是二叉树。 二叉树是树的特殊一种，具有如下特点： 1、每个结点最多有两颗子树，结点的度最大为2。 2、左子树和右子树是有顺序的，次序不能颠倒。 3、即使某结点只有一个子树，也要区分左右子树。 二叉树是一种比较有用的折中方案，它添加，删除元素都很快，并且在查找方面也有很多的算法优化，所以，二叉树既有链表的好处，也有数组的好处，是两者的优化方案，在处理大批量的动态数据方面非常有用。 扩展： 二叉树有很多扩展的数据结构，包括平衡二叉树、红黑树、B+树等，这些数据结构二叉树的基础上衍生了很多的功能，在实际应用中广泛用到，例如mysql的数据库索引结构用的就是B+树，还有HashMap的底层源码中用到了红黑树。这些二叉树的功能强大，但算法上比较复杂，想学习的话还是需要花时间去深入的。 6、散列表 散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。 记录的存储位置=f(key) 这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。 哈希表在应用中也是比较常见的，就如Java中有些集合类就是借鉴了哈希原理构造的，例如HashMap，HashTable等，利用hash表的优势，对于集合的查找元素时非常方便的，然而，因为哈希表是基于数组衍生的数据结构，在添加删除元素方面是比较慢的，所以很多时候需要用到一种数组链表来做，也就是拉链法。拉链法是数组结合链表的一种结构，较早前的hashMap底层的存储就是采用这种结构，直到jdk1.8之后才换成了数组加红黑树的结构，其示例图如下： 从图中可以看出，左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。 哈希表的应用场景很多，当然也有很多问题要考虑，比如哈希冲突的问题，如果处理的不好会浪费大量的时间，导致应用崩溃。 7、堆 堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质： 堆中某个节点的值总是不大于或不小于其父节点的值； 堆总是一棵完全二叉树。 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。 堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。 (ki &lt;= k2i,ki &lt;= k2i+1)或者(ki &gt;= k2i,ki &gt;= k2i+1), (i = 1,2,3,4…n/2)，满足前者的表达式的成为小顶堆，满足后者表达式的为大顶堆，这两者的结构图可以用完全二叉树排列出来，示例图如下： 因为堆有序的特点，一般用来做数组中的排序，称为堆排序。 8、图 图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。 按照顶点指向的方向可分为无向图和有向图： 图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构。","tags":[]},{"title":"AJAX","date":"2021-11-17T01:34:08.000Z","path":"2021/11/17/AJAX/","text":"什么是 AJAX ？ AJAX = 异步 JavaScript 和 XML。 AJAX 是一种用于创建快速动态网页的技术。 通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。 有很多使用 AJAX 的应用程序案例：新浪微博、Google 地图、开心网等等。","tags":[]},{"title":"KMP & 动态规划 & 贪心算法 & Prim算法","date":"2021-11-08T01:29:58.000Z","path":"2021/11/08/算法/","text":"KMP算法 问题 KMP算法指的是字符串模式匹配算法，问题是：在主串T中找到第一次出现完整子串P时的起始位置。 代码实现 123456789101112131415161718192021222324252627282930function KMPSearch(str1, str2, next)&#123; for(var i = 0, j = 0;i&lt;str1.length;i++)&#123; while(j&gt;0 &amp;&amp; str1[i] != str2[j])&#123; j = next[j-1]; &#125; if(str1[i] == str2[j])&#123; j++; &#125; if(j == str2.length)&#123; return i-j+1; &#125; &#125; return -1;&#125;function KMPNext(dest)&#123; var next = new Array(dest.length); for(var i = 0;i&lt;dest.length;i++)&#123; dest[i] = 0; &#125; for(var i = 0, j = 0;i&lt;dest.length;i++)&#123; while(j&gt;0 &amp;&amp; dest[i]!=dest[j])&#123; j = next[j-1]; &#125; if(dest[i] == dest[j])&#123; j++; &#125; next[i] = j; &#125; return next;&#125; 动态规划 背包问题 背包问题：假如目前有三种物品：吉他、音响、电脑，他们的价值分别是1000、2000、2500，重量分别是1磅、3磅、2磅，背包的容量是固定值4磅，现在要把几种物品放进背包中使得在不超重的前提下背包的价值达到最大。 代码实现 123456789101112131415161718192021222324function dynamic_planning()&#123; var val = [1000, 3000, 2500]; var w = [1, 3, 2]; var sum = 4; var v = new Array(w.length); for(var i = 0;i&lt;v.length;i++)&#123; v[i] = new Array(sum); &#125; for(i = 0;i&lt;v.length;i++)&#123; for(var j = 0;j&lt;sum;j++)&#123; v[i][j] = 0; &#125; &#125; for(i = 0;i&lt;v.length;i++)&#123; for(j = 0;j&lt;sum;j++)&#123; if(w[i-1]&gt;j)&#123; v[i][j] = v[i-1][j]; &#125; else&#123; v[i][j] = Math.max(v[i-1][j], val[i-1]+v[i-1][j-w[i-1]]); &#125; &#125; &#125; &#125; 贪心算法（最佳应用：集合覆盖问题） **概念：**贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解 。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择。 *算法思路： 1）遍历所有的广播电台，找到一个覆盖了最多未覆盖的地区的电台（此电台可能包含一些已覆盖的地区，但没关系） 2）将这个电台加入到一个集合中（比如ArrayList），想办法把电台覆盖的地区在下次比较时去掉。 3）重复第一步，直到覆盖了全部的地区。 Prim算法（应用场景：修路问题）","tags":[]},{"title":"树","date":"2021-10-22T02:27:43.000Z","path":"2021/10/22/Tree/","text":"树的基本介绍 树的概念： 树是一种数据结构，它是由n(n≥1)个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点： 每个节点有零个或多个子节点；没有父节点的节点称为根节点；每一个非根节点有且只有一个父节点；除了根节点外，每个子节点可以分为多个不相交的子树。 二叉树： 二叉树是n(n&gt;=0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成。 树的特点： 由二叉树定义以及图示分析得出二叉树有以下特点： 1）每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。 2）左子树和右子树是有顺序的，次序不能任意颠倒。 3）即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。 性质： 1）在二叉树的第i层上最多有2i-1 个节点 。（i&gt;=1） 2）二叉树中如果深度为k,那么最多有2k-1个节点。(k&gt;=1） 3）n0=n2+1 n0表示度数为0的节点数，n2表示度数为2的节点数。 4）在完全二叉树中，具有n个节点的完全二叉树的深度为[log2n]+1，其中[log2n]是向下取整。 5）若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下特性： (1) 若 i=1，则该结点是二叉树的根，无双亲, 否则，编号为 [i/2] 的结点为其双亲结点; (2) 若 2i&gt;n，则该结点无左孩子， 否则，编号为 2i 的结点为其左孩子结点； (3) 若 2i+1&gt;n，则该结点无右孩子结点， 否则，编号为2i+1 的结点为其右孩子结点。 二叉树遍历 前序遍历，中序遍历，后序遍历。 前序遍历通俗的说就是从二叉树的根结点出发，当第一次到达结点时就输出结点数据，按照先向左在向右的方向访问。中序后序以此类推。 1234567891011121314151617181920//前序遍历&lt;script type=&quot;text/javascript&quot;&gt; function TreeNode(val) &#123; this.val = val; this.left = this.right = null; &#125; function preorderTraversal(root)&#123; const res = []; function inorder(root) &#123; if(root==null) return; res.push(root.val); inorder(root.left);//递归 inorder(root.right); &#125; inorder(root); &#125;&lt;/script&gt; 12345678910//中序遍历function inorderTraversal(root)&#123; const res = []; function inorder(root) &#123; if(root==null) return; inorder(root.left);//递归 res.push(root.val); inorder(root.right); &#125; 12345678910//后序遍历function postorderTraversal(root)&#123; const res = []; function inorder(root) &#123; if(root==null) return; inorder(root.left);//递归 inorder(root.right); res.push(root.val); &#125; 二叉树结点删除 规定： 1）如果删除的节点是叶子节点，则删除该节点 2）如果删除的节点是非叶子节点，则删除该子树 思路： 1）考虑树是空树root。那么只有一个root节点，则等价将二叉树置空。 2）因为我们的二叉树是单向的，所以我们是判断当前节点的子节点是否删除节点，而不能去判断当前节点是不是需要删除节点。 3）如果当前节点的左子节点不为空，并且左子节点就是需要删除节点，就将this.left = null，并且就返回（结束递归删除） 4）如果当前节点的右子节点不为空，并且右子节点就是需要删除节点，就将this.right= null，并且就返回（结束递归删除） 5）如果第2步和第3步没有删除节点，那么我们就需要向左子树进行递归删除 6）如果第4步没有删除节点，则应当向右子树进行递归删除。","tags":[{"name":"tree","slug":"tree","permalink":"http://example.com/tags/tree/"}]},{"title":"sort","date":"2021-10-22T01:37:26.000Z","path":"2021/10/22/sort/","text":"Bubble Sorting 冒泡排序：（Bubble Sorting）：通过对待排序序列从前向后（从下标较小的元素开始）通过依次比较相邻的元素的值，若发现逆序则交换，使值较大的元素逐渐从前向后移动，就像水底的气泡一样逐渐网上冒。 1234567891011121314151617181920function bubbleSort(arr) &#123; var i = arr.length, j; var tempExchangVal; while (i &gt; 0) &#123; for (j = 0; j &lt; i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; tempExchangVal = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tempExchangVal; &#125; &#125; i--; &#125; return arr;&#125; var arr = [3, 2, 4, 9, 1, 5, 7, 6, 8];var arrSorted = bubbleSort(arr);console.log(arrSorted);alert(arrSorted); 选择排序 选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 算法描述： n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： 初始状态：无序区为R[1…n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1…i-1]和R(i…n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1…i]和R[i+1…n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1趟结束，数组有序化了。 12345678910111213141516function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; // 寻找最小的数 minIndex = j; // 将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr;&#125; 插入排序 通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 代码中定义了两个指针：currentIndex，preIndex。 123456789101112131415161718192021var currentIndex, preIndex, value; for(var i = 1;i&lt;arr.length;i++) &#123; currentIndex = i; preIndex = i-1; value = arr[currentIndex]; while(value&lt;arr[preIndex] &amp;&amp; preIndex&gt;=0) &#123; arr[currentIndex] = arr[preIndex]; currentIndex = preIndex; preIndex--; &#125; arr[preIndex+1] = value; &#125; return arr; &#125; var arr = [-1, 2, 5, 9, 1, 5, 7, 6, 8]; var arrSorted = InsertSort(arr); console.log(arrSorted); alert(arrSorted); 希尔排序（shell sorting） 它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 算法描述： 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 123456789101112131415161718function ShellSort(arr) &#123; var k = 0; for(var gap = Math.floor(arr.length/2 ); gap&gt;=1; Math.floor(gap /= 2)) &#123; k =0; while(k&lt;arr.length-gap) &#123; if(arr[k]&gt;arr[k+gap]) &#123; t = arr[k]; arr[k] = arr[k+gap]; arr[k+gap] = t; &#125; k++; &#125; &#125; return arr; &#125; 归并排序（merge sorting） 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 算法描述： 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 12345678910111213141516171819202122232425262728function MergeSorting(arr) &#123; if(arr.length&lt;2) return arr; var middle = Math.floor(arr.length/2); var left = arr.slice(0, middle); var right = arr.slice(middle, arr.length); return Merge(MergeSorting(left), MergeSorting(right)); &#125;function Merge(left, right)&#123; var result = []; while(left.length&gt;0&amp;&amp;right.length&gt;0)&#123; if(left[0]&gt;right[0]) &#123; result.push(right.shift()); &#125; else&#123; result.push((left.shift())) &#125;&#125; while(left.length)&#123; result.push(left.shift()); &#125; while(right.length)&#123; result.push(right.shift()); &#125; return result;&#125; 快速排序（quick sorting） 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 算法描述 快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;bottom&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function quicksort(arr, left, right)&#123; var l = left; var r = right; var pivot = arr[Math.floor((left+right)/2)]; while (l&lt;r)&#123; while(arr[l]&lt;pivot)&#123; l++; &#125; while(arr[r]&gt;pivot)&#123; r--; &#125; if(l&gt;=r)&#123; break; &#125; var temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; if(arr[l] == pivot)&#123; r--; &#125; if(arr[r]==pivot)&#123; l++; &#125; &#125; if(l==r)&#123;//防止栈溢出 l++; r--; &#125; if(left&lt;r)&#123;//向左递归 quicksort(arr, left, r); &#125; if(right&gt;l)&#123;//向右递归 quicksort(arr, l, right); &#125; &#125; var arr = [1,2,-1,5,7,3,0]; quicksort(arr, 0, arr.length-1); alert(arr); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 我是bottom；&lt;/body&gt;&lt;/html&gt; 桶排序 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。 算法描述 设置一个定量的数组当作空桶； 遍历输入数据，并且把数据一个一个放到对应的桶里去； 对每个不是空的桶进行排序； 从不是空的桶里把排好序的数据拼接起来。 12345678910111213141516171819202122232425262728293031function BucketSorting(arr)&#123; var maxvalue = arr[0]; for(var i = 1; i&lt;arr.length;i++)&#123; if(maxvalue&lt;arr[i])&#123; maxvalue = arr[i]; &#125; &#125; var maxlen = (maxvalue + &quot;&quot;).length; for(var i = 0,n = 1;i&lt;maxlen;i++,n*=10)&#123; var takenvalue; var returnResult = new Array(); for (var k = 0; k&lt;10;k++)&#123; returnResult[i]=[]; &#125; var arrlen = new Array(10); for(var j = 0;j&lt;arr.length;j++)&#123; takenvalue = Math.floor(arr[j]/n%10); alert(typeof arr[j]); returnResult[takenvalue].push(arr[j]); arrlen[takenvalue] += 1; &#125; var index = 0; for(var k = 0;k&lt;10;k++)&#123; if(arrlen[k]&gt;0)&#123; for(var m = 0;m&lt;arrlen[k];m++) arr[index++] = returnResult[k][m]; &#125; &#125; &#125; return arr; &#125;","tags":[{"name":"bubble sorting,select sorting,insertion sorting,shell sorting","slug":"bubble-sorting-select-sorting-insertion-sorting-shell-sorting","permalink":"http://example.com/tags/bubble-sorting-select-sorting-insertion-sorting-shell-sorting/"}]},{"title":"jQuery & bootstrap","date":"2021-10-20T02:34:18.000Z","path":"2021/10/20/jQuery & bootstrap/","text":"jQuery语法 jQuery 语法是通过选取 HTML 元素，并对选取的元素执行某些操作。 基础语法： $(*selector*).*action*() 美元符号定义 jQuery 选择符（selector）“查询&quot;和&quot;查找” HTML 元素 jQuery 的 action() 执行对元素的操作 实例: $(this).hide() - 隐藏当前元素 $(“p”).hide() - 隐藏所有 元素 $(“p.test”).hide() - 隐藏所有 class=“test” 的 元素 $(“#test”).hide() - 隐藏 id=“test” 的元素 文档就绪事件 您也许已经注意到在我们的实例中的所有 jQuery 函数位于一个 document ready 函数中： 123$(document).ready(function()&#123; // 开始写 jQuery 代码... &#125;); 这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作。 如果在文档没有完全加载之前就运行函数，操作可能失败。下面是两个具体的例子： 试图隐藏一个不存在的元素 获得未完全加载的图像的大小 **提示：**简洁写法（与以上写法效果相同）: 123$(function()&#123; // 开始写 jQuery 代码... &#125;); 以上两种方式你可以选择你喜欢的方式实现文档就绪后执行 jQuery 方法。 jQuery选择器 jQuery 选择器允许您对 HTML 元素组或单个元素进行操作。 jQuery 选择器基于元素的 id、类、类型、属性、属性值等&quot;查找&quot;（或选择）HTML 元素。 它基于已经存在的 CSS 选择器，除此之外，它还有一些自定义的选择器。 jQuery 中所有选择器都以美元符号开头：$()。 元素选择器 jQuery 元素选择器基于元素名选取元素。 在页面中选取所有 元素: 1$(&quot;p&quot;) #id 选择器 jQuery #id 选择器通过 HTML 元素的 id 属性选取指定的元素。 页面中元素的 id 应该是唯一的，所以您要在页面中选取唯一的元素需要通过 #id 选择器。 通过 id 选取元素语法如下： 1$(&quot;#test&quot;) .class 选择器 jQuery 类选择器可以通过指定的 class 查找元素。 语法如下： 1$(&quot;.test&quot;) jQuery事件 页面对不同访问者的响应叫做事件。 事件处理程序指的是当 HTML 中发生某些事件时所调用的方法。 实例： 在元素上移动鼠标。 选取单选按钮 点击元素 click() click() 方法是当按钮点击事件被触发时会调用一个函数。 该函数在用户点击 HTML 元素时执行。 在下面的实例中，当点击事件在某个 元素上触发时，隐藏当前的 元素： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;&gt; &lt;/script&gt; &lt;script&gt; $(function()&#123; $(&quot;p&quot;).click(function()&#123; $(this).hide(); &#125;)&#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;如果你点我，我就会消失。&lt;/p&gt; &lt;p&gt;继续点我!&lt;/p&gt; &lt;p&gt;接着点我!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; dblclick() – 鼠标双击事件， mouseenter() – 当鼠标指针穿过元素， mouseleave() – 当鼠标指针离开元素 ，mousedown() – 当鼠标指针移动到元素上方，并按下鼠标按键，等等。 jQuery Fading 方法： 通过 jQuery，您可以实现元素的淡入淡出效果。 jQuery 拥有下面四种 fade 方法： fadeIn() fadeOut() fadeToggle() fadeTo() jQuery动画–animate() 方法 jQuery animate() 方法用于创建自定义动画。 语法： $(selector).animate({params},speed,callback); 必需的 params 参数定义形成动画的 CSS 属性。 可选的 speed 参数规定效果的时长。它可以取以下值：“slow”、“fast” 或毫秒。 可选的 callback 参数是动画完成后所执行的函数名称。 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;&gt; &lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; $(&quot;button&quot;).click(function()&#123; $(&quot;div&quot;).animate(&#123;left:&#x27;250px&#x27;&#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;开始动画&lt;/button&gt;&lt;p&gt;默认情况下，所有的 HTML 元素有一个静态的位置，且是不可移动的。 如果需要改变为，我们需要将元素的 position 属性设置为 relative, fixed, 或 absolute!&lt;/p&gt;&lt;div style=&quot;background:#98bf21;height:100px;width:100px;position:absolute;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Bootstrap 我的第一个用了[boostrap][https://v3.bootcss.com]的代码： 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Bootstrap 实例 - 响应式的列重置&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class = &quot;container&quot;&gt;&lt;!-- .container 类用于固定宽度并支持响应式布局的容器--&gt; 123 &lt;/div&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;!-- .container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器。--&gt; 456 &lt;/div&gt; &lt;table class=&quot;table table-bordered&quot;&gt;&lt;!-- 添加 .table-bordered 类为表格和其中的每个单元格增加边框。--&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;科目&lt;/td&gt; &lt;td&gt;成绩&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;夏明&lt;/td&gt; &lt;td&gt;数学&lt;/td&gt; &lt;td&gt;149&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;徐雪&lt;/td&gt; &lt;td&gt;英语&lt;/td&gt; &lt;td&gt;139&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 要使用boostrap，下面这些代码是必须要添加上的： 123&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 栅格系统 Bootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。它包含了易于使用的预定义类，还有强大的mixin 用于生成更具语义的布局。 123456789101112131415161718192021222324252627&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-8&quot;&gt;.col-md-8&lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt;.col-md-4&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-6&quot;&gt;.col-md-6&lt;/div&gt; &lt;div class=&quot;col-md-6&quot;&gt;.col-md-6&lt;/div&gt;&lt;/div&gt;","tags":[{"name":"introduction hexo","slug":"introduction-hexo","permalink":"http://example.com/tags/introduction-hexo/"}]},{"title":"css","date":"2021-10-08T11:56:19.000Z","path":"2021/10/08/css/","text":"CSS css选择器 css的选择器学习： 123456789101112131415161718192021&lt;style type = &quot;text/css&quot;&gt; /*标签选择器*/ table&#123; height: 300px; width: 200px; border: solid 1px; background-color: red; &#125; /*id选择器*/ #t1&#123; background-color: blue; &#125; /*类选择器*/ .common&#123; color:red; &#125; /*组合选择器*/ table,.common&#123; color:red; &#125; &lt;/style&gt; 标签选择器：标签名{样式名1：样式值1；…} 作用：会将当前网页内所有该标签增加相同的样式 id选择器：#标签的id属性值{样式名1：样式值1；…} 作用：给某个指定的标签添加样式 类选择器：.类选择器名{样式名1：样式值1；…} 作用：给不同的标签添加相同的样式 全部选择选择器：*{样式名1：样式值1；…} 作用：选择所有的HTML标签，并添加相同的样式 组合选择器：选择器1，选择器2，…{样式名1：样式值1；…} 作用：解决不同的选择器之间重复样式的问题 css样式 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;照片墙&lt;/title&gt; &lt;style type = &quot;text/css&quot;&gt; body&#123; text-align: center; background-color: gray; &#125; img&#123; width: 20%;/*设置高度*/ padding: 10px;/*设置内边距*/ background-color: white;/*设置背景颜色*/ transform: rotate(-10deg);/*设置倾斜角度*/ margin-left: 10px;/*设置外边距*/ &#125; img:hover&#123; transform: rotate(0deg) scale(1.5);/*设置倾斜角度和缩放比例*/ z-index: 2;/* 设置显示优先级别*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt; &lt;img src=&quot;https://img0.baidu.com/it/u=652732258,3535184171&amp;fm=26&amp;fmt=auto&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://img0.baidu.com/it/u=3459544028,1422320751&amp;fm=26&amp;fmt=auto&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://img1.baidu.com/it/u=3806063294,3480903396&amp;fm=26&amp;fmt=auto&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://img0.baidu.com/it/u=121804161,3053314887&amp;fm=26&amp;fmt=auto&quot; alt=&quot;&quot;/&gt; &lt;br/&gt;&lt;br/&gt; &lt;img src=&quot;https://img2.baidu.com/it/u=3108583535,4104247024&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=640&amp;h=360&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://img0.baidu.com/it/u=2135482323,1459336928&amp;fm=26&amp;fmt=auto&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fn.sinaimg.cn%2Fsinacn%2Fw500h280%2F20171219%2F13f2-fypvuqe0957796.gif&amp;refer=http%3A%2F%2Fn.sinaimg.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1636370856&amp;t=e55fc69178ee867433ab3e74c60adbf2&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://img2.baidu.com/it/u=2414916686,3188715239&amp;fm=26&amp;fmt=auto&quot; alt=&quot;&quot;/&gt; &lt;hr/&gt;&lt;/body&gt;&lt;/html&gt; 盒子模型 外边距：margin 作用：用来设置元素与元素之间的间隔 居中设置：margin：0px auto；上下间隔是0px，水平居中。 边框：border 作用：用来设置元素的边框大小，可以单独设置上下左右 内边距：padding 作用：设置内容与边框之间的距离，内边距不会改变内容区域的大小，可以单独设置上下左右的内边距 内容区域：改变内容区域的大小，设置宽和高即可改变内容区域的大小。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;盒子模型&lt;/title&gt; &lt;style type = &quot;text/css&quot;&gt; div&#123; width: 300px; height: 300px; &#125; #div01&#123; border: solid 1px orange; &#125; #div02&#123; border:solid 1px blueviolet; &#125; #div03&#123; border:solid 1px aqua; &#125; #div04&#123; border:bisque; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id = &quot;div01&quot;&gt; 我是div01 &lt;/div&gt; &lt;div id = &quot;div02&quot;&gt; 我是div02 &lt;/div&gt; &lt;div id = &quot;div03&quot;&gt; 我是div03 &lt;/div&gt; &lt;div id = &quot;div04&quot;&gt; 我是div04 &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":[]},{"title":"html","date":"2021-09-29T07:18:59.000Z","path":"2021/09/29/html/","text":"[TOC] HTML基础学习 body 标签 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 aligh = &quot;left&quot;&gt; 全红禅祝大家国庆节快乐！&lt;/h1&gt;&lt;hr width = &quot;20%&quot; size = 5px color = &quot;purple&quot;/&gt;&lt;p&gt; 全红婵发文祝大家国庆节快乐，并且晒出长隆假期游玩照，准备恢复挥汗如雨的训练生活了，妹妹玩得开心啊! 妹妹真的太可爱了!&lt;/p&gt; 哈哈哈，&lt;b&gt;全红婵&lt;/b&gt;妹妹有心啦！特意发文祝大家国庆节快乐！还真是个体贴又温暖的&lt;i&gt;女孩呢！&lt;/i&gt;&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;你也要快乐过节，&lt;u&gt;快乐训练！&lt;/u&gt;期待你下次精彩表现。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 标题标签： h1到h6：将其中的内容加粗加黑显示，并且显示依次减弱，自带换行功能（块级标签）。 属性：aligh = “center”/ “left”/“right” 水平线标签：hr 在页面中显示一条水平线，默认居中显示 属性：width = “宽度” 设置水平线的宽度 size = “高度” 设置水平线的高度 color = “颜色” 设置水平线的颜色 段落标签：p 会将一段数据作为整体进行显示自动换行，段间距比较大 换行符：br 告诉浏览器在此位置增加空格 权重标签： b 会将内容加黑显示 i 会将内容斜体显示 u 会将内容增加下划线 del 增加中划线 表单学习 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;table border=&quot;1px&quot; cellspacing=&quot;0px&quot; cellpadding=&quot;8px&quot;&gt; &lt;tr height = &quot;27px&quot;&gt; &lt;td colspan=&quot;5&quot;&gt;基本情况&lt;/td&gt; &lt;/tr&gt; &lt;tr height = &quot;27px&quot;&gt; &lt;td width = &quot;120px&quot;&gt;姓名&lt;/td&gt; &lt;td width = &quot;120px&quot;&gt;&lt;/td&gt; &lt;td width = &quot;120px&quot;&gt;性别&lt;/td&gt; &lt;td width = &quot;120px&quot;&gt;&lt;/td&gt; &lt;td width = &quot;120px&quot; rowspan=&quot;7&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height = &quot;27px&quot;&gt; &lt;td&gt;民族&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;出生年月&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height = &quot;27px&quot;&gt; &lt;td&gt;政治面貌&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;健康&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height = &quot;27px&quot;&gt; &lt;td&gt;籍贯&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;学历&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height = &quot;27px&quot;&gt; &lt;td&gt;电子信箱&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;联系电话&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height = &quot;27px&quot;&gt; &lt;td&gt;专业&lt;/td&gt; &lt;td colspan=&quot;3&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height = &quot;27px&quot;&gt; &lt;td&gt;毕业院校&lt;/td&gt; &lt;td colspan=&quot;3&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height = &quot;27px&quot;&gt; &lt;td&gt;求职意向&lt;/td&gt; &lt;td colspan=&quot;4&quot;&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; table：声明一个表格 tr：声明一行，设置行高以及该行所有单元格的高度 th：声明一个单元格，表头格，默认居中加黑显示 td：声明一个单元格，默认居左显示原始数据 注意：行高即该行所有单元格的宽度，单元格的宽度即列宽 简单写法：五行六列的表格 1table&gt;tr*5&gt;td*6 属性： border：给表格添加边框 width：设置表格的宽度 height：设置表格的高度 cellpadding：设置内容居边框的距离 cellspacing：设置边框的大小 单元格合并： 第一步：首先确保表格是一个规整的表格 第二步：根据要合并的单元格，找到其所在的源码位置 第三步： 行合并：在要合并的单元格中第一个单元格上使用属性rowspan=“要合并的单元格的个数”，并删除其他单元格完成合并 列合并：在要合并的单元格中任意一个上使用属性colspan = &quot;要合并的单元格的个数&quot;并删除其他要合并的单元格完成合并 内嵌标签学习 内嵌标签：iframe src：要显示的网页资源路径，可以是本地（相对路径）也可以是网络资源（URL），默认当前页面打开及加载src指向的资源 width：设置区域的宽度 height：设置区域的高度 form表单标签 作用：收集并提交用户数据给指定服务器。 注意：form标签会收集其标签内部的数据，要提交的表单项必须拥有name属性，否则不会提交 属性： action：收集的数据的提交地址，URL method：收集的数据的提交方式， get：适合小量数据，表单数据以？隔开拼接在用户书写的URL后面，不同的键值对用&amp;连接，不安全。 post：适合大量数据，安全，隐式提交。 表单域标签：作用：给用户提供可以进行数据书写或者选择的标签， 文本框：input： type： text 收集少量文本数据，用户可见 password 收集用户密码数据 name：数据提交的键，也会被js使用 value：默认值 单选框：type = “radio”，name属性相同的只能选一项数据 value 要提交的数据，checked checked使用此属性的单选默认是选择状态 form表单标签：form标签会将其内部所有的form表单标签中的所有的用户数据按照method指定的提交方式提交给action指明的地址 123456&lt;form action = &#x27;#&#x27; method=&quot;get&quot;&gt; 用户名&lt;input type=&quot;text&quot; name = &quot;rtr&quot;/&gt;&lt;br/&gt; 密码&lt;input type = &quot;text&quot; name = &quot;uid&quot;/&gt;&lt;br&gt; &lt;input type = &quot;submit&quot; value=&quot;提交&quot;/&gt; 性别：男&lt;input type = &quot;radio&quot; name = &quot;sex&quot; value = &quot;male&quot; checked = &quot;checked&quot;/&gt;女&lt;input type = &quot;radio&quot; name = &quot;sex&quot; value = &quot;female&quot;/&gt;&lt;/form&gt;","tags":[]},{"title":"Array","date":"2021-09-24T01:02:03.000Z","path":"2021/09/24/JS-Array/","text":"数组的基本操作（Array） 数组也是一个对象，不同的是普通的对象是使用字符串作为属性名，而数组是使用数字作为索引来操作元素。 数组长度没有限制，数组元素可以是数据类型。 数组创建： 12345var arr = new Array();//使用构造函数创建数组，无参；var arr0 = new Array(10, 20, 30);//使用构造函数创建数组时，也可以同时添加元素，将要添加的元素作为构造函数的参数传递，元素间用，隔开；var arr1 = new Array(10);//长度为10var arr2 = [];var arr3 = [1,2,3,4]; 使用typeof检查一个数组时，会返回object。 123console.log(typeof arr)//返回objectarr[0] = 10;//添加元素，索引是从0开始的整数。console.log(arr.length)//获取数组的长度 增删 12345arr.push(&quot;唐僧&quot;, &quot;蜘蛛精&quot;);//向数组末尾添加一个或者多个元素，并返回数组新的长度arr.unshift(&quot;牛魔王&quot;);//向数组的开头添加一个或者多个元素，并返回新的数组长度arr.pop();//删除数组最后一个元素，并将被删除的元素返回arr.shift();//删除数组的第一个元素，并将被删除的元素返回 数组遍历： 1234for(var i = 0;i&lt;arr.length;i++)&#123; console.log(arr[i]);&#125; forEach(这个方法只支持IE8以上的浏览器) 12345arr.forEach(function(a)&#123; console.log(&quot;hello&quot;); console.log(a); &#125;);//像这种函数，由我们创建但不由我们调用，回调函数,数组中有几个元素就会执行几次。每次执行时，浏览器会将遍历到的元素以实参的形式传递进来，我们可以定义形参来读取这些内容。浏览器会在回调函数中传递三个参数：第一个就是当前正在遍历的元素，第二个参数是当前正在遍历元素的索引，第三个参数是正在遍历的数组对象 slice|splice 12var result = arr.slice(0, 2);//截取开始位置的索引，截取结束位置的索引，包含开始不包含结束索引。该方法不会改变元素数组，而是将截取到的元素封装到一个新的数组中；第二个参数可以省略不写，此时会截取从开始索引往后的所有元素；索引可以传递一个负值，如果传递一个负值，则从后往前计算，-1倒数第一个。var result = arr.splice(0, 2, &quot;牛魔王&quot;);//可以用于删除数组中的指定元素，会将指定元素从原数组中删除，并将被删除的元素作为返回值返回。第一个表示开始位置的索引，第二个表示删除的数量，第三个及以后的元素：可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边。 去重 12345678910111213var arr = [1,2,3,2,2,1,3,4,2,5];for(var i = 0;i&lt;arr.length;i++)&#123; for(var j = i+1;j&lt;arr.length;j++) &#123; if(arr[i] == arr[j]) &#123; arr.splice(j, 1); //当删除了当前j所在的元素以后，后面的元素会自动补位。元素的长度也会跟着改变。 j--; &#125; &#125;&#125; concat|join|reverse|sort 123456789101112131415var arr = [&quot;孙悟空&quot;, &quot;猪八戒&quot;];var arr2 = [&quot;白骨精&quot;,&quot;蜘蛛精&quot;]result = arr.concat(arr2,&quot;牛魔王&quot;);//该方法可以连接两个或者多个数组，并将新的数组返回，不会对原数组产生影响result = arr.join(&quot;@-@&quot;);//该方法可以将数组转换为一个字符串，该方法不会对原数组产生影响，而是将转换后的字符串返回，在join()中可以指定字符串作为参数，该参数会成为数组中的元素连接符，默认为&quot;,&quot;。arr.reverse();//该方法用来反转数组，修改原数组arr.sort();//用来对数组中的元素进行排序，修改原数组，默认会按照Unicode编码进行排序，即使对于纯数字的数组，可能会得到错误结果。添加回调函数，指定排序规则，回调函数中定义两个形参，a在b前面：arr.sort(funtion(a,b)&#123; if(a&gt;b) return 1; else return 0; &#125;);arr.sort(funtion(a,b)&#123; return a-b; &#125;); indexOf array.indexOf 此方法判断数组中是否存在某个值，如果存在返回数组元素的下标，否则返回-1 123let arr = [&#x27;something&#x27;, &#x27;anything&#x27;, &#x27;nothing&#x27;, &#x27;anything&#x27;];let index = arr.indexOf(&#x27;nothing&#x27;);console.log(index) //结果是2","tags":[]},{"title":"JS study","date":"2021-09-23T07:02:25.102Z","path":"2021/09/23/js基础/","text":"输出语句 JavaScript 没有任何打印或者输出的函数。JavaScript 可以通过不同的方式来输出数据： 使用 window.alert() 弹出警告框。 使用 document.write() 方法将内容写到 HTML 文档中。 使用 innerHTML 写入到 HTML 元素。 使用 console.log() 写入到浏览器的控制台。 一个需要注意的点：return 语句，少写了return语句返回值会是undefined，在你得到输出的结果是undefined时要想到是不是少了return。 for循环的使用 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;study&lt;/title&gt; &lt;script type = &quot;text/javascript&quot;&gt; for(var i = 10;i&lt;15;i++) &#123; document.write(i); document.write(&#x27;&lt;br /&gt;&#x27;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; JS中的for循环与JAVA中的很相似，这里就不多说了。注意：JS中的换行符是 1&lt;br /&gt; 条件语句 1234if(age &gt;= 18)&#123; console.log(age);&#125; 对象的属性 123var obj = new Object();obj.name = &quot;孙悟空&quot;;obj.var = 798; 对象的属性名不强制要求遵守标识符的规范，但是我们使用时还是尽量按照标识符的规范去做。如果要使用特殊的属性名，不能采用.的方式来操作，使用：对象[“属性名”] = 属性值。 JS的普通函数 声明方式一： 12345678910function fun()&#123; var sum = 0; for(var i = 0; i&lt;100; i++) &#123; sum += i; &#125; return sum&#125;alert(fun()); 声明方式二： 123456789var fun = function()&#123; var sum = 0; for(var i = 0; i&lt;100; i++) &#123; sum += i; &#125; return sum &#125; alert(fun()); 箭头函数 ES6标准新增了一种新的函数：Arrow Function（箭头函数） 1x =&gt; x * x 相当于： 123function (x) &#123; return x * x;&#125; 箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连&#123; ... &#125;和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略&#123; ... &#125;和return： 12345678x =&gt; &#123; if (x &gt; 0) &#123; return x * x; &#125; else &#123; return - x * x; &#125;&#125; 如果参数不是一个，就需要用括号()括起来： 1234567891011121314// 两个参数:(x, y) =&gt; x * x + y * y// 无参数:() =&gt; 3.14// 可变参数:(x, y, ...rest) =&gt; &#123; var i, sum = x + y; for (i=0; i&lt;rest.length; i++) &#123; sum += rest[i]; &#125; return sum;&#125; JS的构造方法 首先展示一个简单的代码： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;study&lt;/title&gt; &lt;script type = &quot;text/javascript&quot;&gt; function Person(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender; alert(&quot;Hello!&quot;); this.changeName=changeName; function changeName(name) &#123; this.lastname=name; &#125;//changeName() 函数 name 的值赋给 person 的 lastname 属性。 &#125; var Jogh = new Person(&quot;jogh&quot;, 12, &quot;male&quot;);// 如果 new 了函数内的 this 会指向当前这个 person 并且就算函数内部不 return 也会返回一个对象。 &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 在编写js代码的时候需要添加如下语句来声明这是一个JS代码块。 12&lt;script type = &quot;text/javascript&quot;&gt;&lt;/script&gt; 上述代码块中，Person是一个带参数的构造方法，this是指代该构造方法生成的对象；构造方法与普通方法不同之处在于构造方法调用的时候前面有一个关键字new。 原型prototype 在我们所创建的每一个函数，解析器都会函数添加一个属性prototype,这个属性对应着一个对象，这个对象就是我们所谓的原型对象。如果函数作为普通函数调用prototype，这个对象没有任何作用。当函数以构造函数调用，他所创建的对象中都会有一个隐含的属性，通过__proto__来访问该属性。原型对象相当于一个公共的区域，所有的同一类的实例都可以访问到这个原型对象。 123456function MyClass()&#123;&#125;function Person()&#123;&#125;var per = new Person();MyClass.prototype == per.__proto__//true 程序中调试是测试，查找及减少bug(错误)的过程。 关键字let 和 const ES6 可以使用 let 关键字来实现块级作用域。 let 声明的变量只在 let 命令所在的代码块 {} 内有效，在 {} 之外不能访问。 1234&#123; let x = 2;&#125;// 这里不能使用 x 变量 const 用于声明一个或多个常量，声明时必须进行初始化，且初始化后值不可再修改： 1const PI = 3.141592653589793; PI = 3.14; // 报错 PI = PI + 10; // 报错 JSON JSON 英文全称 JavaScript Object Notation； JSON 是一种轻量级的数据交换格式； JSON是独立的语言； JSON 易于理解。 JSON 语法规则 数据为 键/值 对。 数据由逗号分隔。 大括号保存对象 方括号保存数组","tags":[]}]