[{"title":"Array","date":"2021-09-24T01:02:03.000Z","path":"2021/09/24/Array/","text":"数组的基本操作（Array）数组也是一个对象，不同的是普通的对象是使用字符串作为属性名，而数组是使用数字作为索引来操作元素。 数组长度没有限制，数组元素可以是数据类型。 数组创建：12345var arr = new Array();//使用构造函数创建数组，无参；var arr0 = new Array(10, 20, 30);//使用构造函数创建数组时，也可以同时添加元素，将要添加的元素作为构造函数的参数传递，元素间用，隔开；var arr1 = new Array(10);//长度为10var arr2 = [];var arr3 = [1,2,3,4]; 使用typeof检查一个数组时，会返回object。 123console.log(typeof arr)//返回objectarr[0] = 10;//添加元素，索引是从0开始的整数。console.log(arr.length)//获取数组的长度 增删12345arr.push(&quot;唐僧&quot;, &quot;蜘蛛精&quot;);//向数组末尾添加一个或者多个元素，并返回数组新的长度arr.unshift(&quot;牛魔王&quot;);//向数组的开头添加一个或者多个元素，并返回新的数组长度arr.pop();//删除数组最后一个元素，并将被删除的元素返回arr.shift();//删除数组的第一个元素，并将被删除的元素返回 数组遍历：1234for(var i = 0;i&lt;arr.length;i++)&#123; console.log(arr[i]);&#125; forEach(这个方法只支持IE8以上的浏览器)12345arr.forEach(function(a)&#123; console.log(&quot;hello&quot;); console.log(a); &#125;);//像这种函数，由我们创建但不由我们调用，回调函数,数组中有几个元素就会执行几次。每次执行时，浏览器会将遍历到的元素以实参的形式传递进来，我们可以定义形参来读取这些内容。浏览器会在回调函数中传递三个参数：第一个就是当前正在遍历的元素，第二个参数是当前正在遍历元素的索引，第三个参数是正在遍历的数组对象 slice|splice12var result = arr.slice(0, 2);//截取开始位置的索引，截取结束位置的索引，包含开始不包含结束索引。该方法不会改变元素数组，而是将截取到的元素封装到一个新的数组中；第二个参数可以省略不写，此时会截取从开始索引往后的所有元素；索引可以传递一个负值，如果传递一个负值，则从后往前计算，-1倒数第一个。var result = arr.splice(0, 2, &quot;牛魔王&quot;);//可以用于删除数组中的指定元素，会将指定元素从原数组中删除，并将被删除的元素作为返回值返回。第一个表示开始位置的索引，第二个表示删除的数量，第三个及以后的元素：可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边。","tags":[]},{"title":"JS study","date":"2021-09-23T07:02:25.102Z","path":"2021/09/23/my-first-blog/","text":"JS学习for循环的使用123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;study&lt;/title&gt; &lt;script type = &quot;text/javascript&quot;&gt; for(var i = 10;i&lt;15;i++) &#123; document.write(i); document.write(&#x27;&lt;br /&gt;&#x27;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; JS中的for循环与JAVA中的很相似，这里就不多说了。注意：JS中的换行符是 1&lt;br /&gt; 条件语句1234if(age &gt;= 18)&#123; console.log(age);&#125; 对象的属性123var obj = new Object();obj.name = &quot;孙悟空&quot;;obj.var = 798; 对象的属性名不强制要求遵守标识符的规范，但是我们使用时还是尽量按照标识符的规范去做。如果要使用特殊的属性名，不能采用.的方式来操作，使用：对象[“属性名”] = 属性值。 JS的普通函数声明方式一： 12345678910function fun()&#123; var sum = 0; for(var i = 0; i&lt;100; i++) &#123; sum += i; &#125; return sum&#125;alert(fun()); 声明方式二： 123456789var fun = function()&#123; var sum = 0; for(var i = 0; i&lt;100; i++) &#123; sum += i; &#125; return sum &#125; alert(fun()); JS的构造方法首先展示一个简单的代码： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;study&lt;/title&gt; &lt;script type = &quot;text/javascript&quot;&gt; function Person(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender; alert(&quot;Hello!&quot;); &#125; var Jogh = new Person(&quot;jogh&quot;, 12, &quot;male&quot;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 在编写js代码的时候需要添加如下语句来声明这是一个JS代码块。 12&lt;script type = &quot;text/javascript&quot;&gt;&lt;/script&gt; 上述代码块中，Person是一个带参数的构造方法，this是指代该构造方法生成的对象；构造方法与普通方法不同之处在于构造方法调用的时候前面有一个关键字new。 原型prototype在我们所创建的每一个函数，解析器都会函数添加一个属性prototype,这个属性对应着一个对象，这个对象就是我们所谓的原型对象。如果函数作为普通函数调用prototype，这个对象没有任何作用。当函数以构造函数调用，他所创建的对象中都会有一个隐含的属性，通过__proto__来访问该属性。原型对象相当于一个公共的区域，所有的同一类的实例都可以访问到这个原型对象。 123456function MyClass()&#123;&#125;function Person()&#123;&#125;var per = new Person();MyClass.prototype == per.__proto__//true","tags":[]}]